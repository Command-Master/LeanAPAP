import mathlib.analysis.inner_product_space.pi_L2
import mathlib.analysis.normed.group.basic
import mathlib.analysis.normed_space.pi_Lp
import mathlib.analysis.normed_space.ray
import mathlib.analysis.special_functions.pow.real
import mathlib.data.real.basic
import mathlib.data.real.nnreal
import mathlib.order.conditionally_complete_lattice.finset
import prereqs.indicator

/-!
# Lp norms
-/

open finset real
open_locale big_operators complex_conjugate ennreal nnreal

variables {Œπ : Type*} [fintype Œπ]

/-! ### Lp norm -/

section normed_add_comm_group
variables {Œ± : Œπ ‚Üí Type*} [Œ† i, normed_add_comm_group (Œ± i)] {p : ‚Ñù‚â•0‚àû} {f g h : Œ† i, Œ± i}

/-- The Lp norm of a function. -/
noncomputable def Lpnorm (p : ‚Ñù‚â•0‚àû) (f : Œ† i, Œ± i) : ‚Ñù := ‚Äñ(pi_Lp.equiv p _).symm f‚Äñ

notation `‚Äñ` f `‚Äñ_[` p `]` := Lpnorm p f

lemma Lpnorm_eq_sum' (hp : 0 < p.to_real) (f : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p] = (‚àë i, ‚Äñf i‚Äñ ^ p.to_real) ^ p.to_real‚Åª¬π :=
by rw ‚Üêone_div; exact pi_Lp.norm_eq_sum hp _

lemma Lpnorm_eq_sum'' {p : ‚Ñù} (hp : 0 < p) (f : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p.to_nnreal] = (‚àë i, ‚Äñf i‚Äñ ^ p) ^ p‚Åª¬π :=
by rw Lpnorm_eq_sum'; simp [hp, hp.le]

lemma Lpnorm_eq_sum {p : ‚Ñù‚â•0} (hp : 0 < p) (f : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p] = (‚àë i, ‚Äñf i‚Äñ ^ (p : ‚Ñù)) ^ (p‚Åª¬π : ‚Ñù) :=
Lpnorm_eq_sum' hp _

lemma Lpnorm_rpow_eq_sum {p : ‚Ñù‚â•0} (hp : 0 < p) (f : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p] ^ (p : ‚Ñù) = ‚àë i, ‚Äñf i‚Äñ ^ (p : ‚Ñù) :=
begin
  rw [Lpnorm_eq_sum hp, rpow_inv_rpow],
  { exact sum_nonneg (Œª i _, by positivity) },
  { positivity }
end

lemma Lpnorm_pow_eq_sum {p : ‚Ñï} (hp : p ‚â† 0) (f : Œ† i, Œ± i) : ‚Äñf‚Äñ_[p] ^ p = ‚àë i, ‚Äñf i‚Äñ ^ p :=
by simpa using Lpnorm_rpow_eq_sum (nat.cast_pos.2 hp.bot_lt) f

lemma L1norm_eq_sum (f : Œ† i, Œ± i) : ‚Äñf‚Äñ_[1] = ‚àë i, ‚Äñf i‚Äñ := by simp [Lpnorm_eq_sum']

lemma L0norm_eq_card (f : Œ† i, Œ± i) : ‚Äñf‚Äñ_[0] = {i | f i ‚â† 0}.to_finite.to_finset.card :=
pi_Lp.norm_eq_card _

lemma Linftynorm_eq_csupr (f : Œ† i, Œ± i) : ‚Äñf‚Äñ_[‚àû] = ‚®Ü i, ‚Äñf i‚Äñ := pi_Lp.norm_eq_csupr _

@[simp] lemma Lpnorm_zero : ‚Äñ(0 : Œ† i, Œ± i)‚Äñ_[p] = 0 :=
begin
  cases p, swap,
  obtain rfl | hp := @eq_zero_or_pos _ _ p,
  all_goals { simp [Linftynorm_eq_csupr, L0norm_eq_card, Lpnorm_eq_sum, *, ne_of_gt] },
end

@[simp] lemma Lpnorm_norm (f : Œ† i, Œ± i) : ‚ÄñŒª i, ‚Äñf i‚Äñ‚Äñ_[p] = ‚Äñf‚Äñ_[p] :=
begin
  cases p, swap,
  obtain rfl | hp := @eq_zero_or_pos _ _ p,
  all_goals { simp [Linftynorm_eq_csupr, L0norm_eq_card, Lpnorm_eq_sum, *, ne_of_gt] },
end

@[simp] lemma Lpnorm_neg (f : Œ† i, Œ± i) : ‚Äñ-f‚Äñ_[p] = ‚Äñf‚Äñ_[p] := by simp [‚ÜêLpnorm_norm (-f)]

lemma Lpnorm_sub_comm (f g : Œ† i, Œ± i) : ‚Äñf - g‚Äñ_[p] = ‚Äñg - f‚Äñ_[p] := by simp [‚ÜêLpnorm_neg (f - g)]

@[simp] lemma Lpnorm_nonneg : 0 ‚â§ ‚Äñf‚Äñ_[p] :=
begin
  cases p,
  { simp only [Linftynorm_eq_csupr, ennreal.none_eq_top],
    exact real.supr_nonneg (Œª i, norm_nonneg _) },
  obtain rfl | hp := @eq_zero_or_pos _ _ p,
  { simp only [L0norm_eq_card, ennreal.some_eq_coe, ennreal.coe_zero],
    exact nat.cast_nonneg _ },
  { simp only [Lpnorm_eq_sum hp, ennreal.some_eq_coe],
    exact rpow_nonneg (sum_nonneg $ Œª i _, rpow_nonneg $ norm_nonneg _) }
end

@[simp] lemma Lpnorm_eq_zero : ‚Äñf‚Äñ_[p] = 0 ‚Üî f = 0 :=
begin
  cases p,
  { casesI is_empty_or_nonempty Œπ; simp [Linftynorm_eq_csupr, ennreal.none_eq_top,
      ‚Üêsup'_univ_eq_csupr, le_antisymm_iff, function.funext_iff] },
  obtain rfl | hp := @eq_zero_or_pos _ _ p,
  { simp [L0norm_eq_card, eq_empty_iff_forall_not_mem, function.funext_iff] },
  { rw ‚Üêrpow_eq_zero Lpnorm_nonneg (nnreal.coe_ne_zero.2 hp.ne'),
    simp [Lpnorm_rpow_eq_sum hp, sum_eq_zero_iff_of_nonneg, rpow_nonneg, function.funext_iff,
      rpow_eq_zero _ (nnreal.coe_ne_zero.2 hp.ne')] }
end

@[simp] lemma Lpnorm_pos : 0 < ‚Äñf‚Äñ_[p] ‚Üî f ‚â† 0 := Lpnorm_nonneg.gt_iff_ne.trans Lpnorm_eq_zero.not

section one_le

lemma Lpnorm_add_le (hp : 1 ‚â§ p) (f g : Œ† i, Œ± i) : ‚Äñf + g‚Äñ_[p] ‚â§ ‚Äñf‚Äñ_[p] + ‚Äñg‚Äñ_[p] :=
by haveI := fact.mk hp; exact norm_add_le _ _

lemma Lpnorm_sub_le (hp : 1 ‚â§ p) (f g : Œ† i, Œ± i) : ‚Äñf - g‚Äñ_[p] ‚â§ ‚Äñf‚Äñ_[p] + ‚Äñg‚Äñ_[p] :=
by haveI := fact.mk hp; exact norm_sub_le _ _

lemma Lpnorm_le_Lpnorm_add_Lpnorm_sub' (hp : 1 ‚â§ p) (f g  : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p] ‚â§ ‚Äñg‚Äñ_[p] + ‚Äñf - g‚Äñ_[p] :=
by haveI := fact.mk hp; exact norm_le_norm_add_norm_sub' _ _

lemma Lpnorm_le_Lpnorm_add_Lpnorm_sub (hp : 1 ‚â§ p) (f g  : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p] ‚â§ ‚Äñg‚Äñ_[p] + ‚Äñg - f‚Äñ_[p] :=
by haveI := fact.mk hp; exact norm_le_norm_add_norm_sub _ _

lemma Lpnorm_le_add_Lpnorm_add (hp : 1 ‚â§ p) (f g  : Œ† i, Œ± i) : ‚Äñf‚Äñ_[p] ‚â§ ‚Äñf + g‚Äñ_[p] + ‚Äñg‚Äñ_[p] :=
by haveI := fact.mk hp; exact norm_le_add_norm_add _ _

lemma Lpnorm_sub_le_Lpnorm_sub_add_Lpnorm_sub (hp : 1 ‚â§ p) :
  ‚Äñf - h‚Äñ_[p] ‚â§ ‚Äñf - g‚Äñ_[p] + ‚Äñg - h‚Äñ_[p] :=
by haveI := fact.mk hp; exact norm_sub_le_norm_sub_add_norm_sub

variables {ùïú : Type*} [normed_field ùïú] [Œ† i, normed_space ùïú (Œ± i)]

-- TODO: `p ‚â† 0` is enough
lemma Lpnorm_smul (hp : 1 ‚â§ p) (c : ùïú) (f : Œ† i, Œ± i) : ‚Äñc ‚Ä¢ f‚Äñ_[p] = ‚Äñc‚Äñ * ‚Äñf‚Äñ_[p] :=
by haveI := fact.mk hp; exact norm_smul _ _

-- TODO: Why is it so hard to use `Lpnorm_smul` directly? `function.has_smul` seems to have a hard
-- time unifying `pi.has_smul`
lemma Lpnorm_smul' {Œ± : Type*} [normed_add_comm_group Œ±] [normed_space ùïú Œ±] (hp : 1 ‚â§ p) (c : ùïú)
  (f : Œπ ‚Üí Œ±) : ‚Äñc ‚Ä¢ f‚Äñ_[p] = ‚Äñc‚Äñ * ‚Äñf‚Äñ_[p] :=
Lpnorm_smul hp _ _

variables [Œ† i, normed_space ‚Ñù (Œ± i)]

lemma Lpnorm_nsmul (hp : 1 ‚â§ p) (n : ‚Ñï) (f : Œ† i, Œ± i) : ‚Äñn ‚Ä¢ f‚Äñ_[p] = n ‚Ä¢ ‚Äñf‚Äñ_[p] :=
by haveI := fact.mk hp; exact norm_nsmul _ _

-- TODO: Why is it so hard to use `Lpnorm_nsmul` directly? `function.has_smul` seems to have a hard
-- time unifying `pi.has_smul`
lemma Lpnorm_nsmul' {Œ± : Type*} [normed_add_comm_group Œ±] [normed_space ‚Ñù Œ±] (hp : 1 ‚â§ p) (n : ‚Ñï)
  (f : Œπ ‚Üí Œ±) : ‚Äñn ‚Ä¢ f‚Äñ_[p] = n ‚Ä¢ ‚Äñf‚Äñ_[p] :=
Lpnorm_nsmul hp _ _

end one_le
end normed_add_comm_group

section real
variables {p : ‚Ñù‚â•0} {f g : Œπ ‚Üí ‚Ñù}

@[simp] lemma Lpnorm_one (hp : 0 < p) : ‚Äñ(1 : Œπ ‚Üí ‚Ñù)‚Äñ_[p] = (fintype.card Œπ) ^ (p‚Åª¬π : ‚Ñù) :=
by simp [Lpnorm_eq_sum hp, card_univ]

lemma Lpnorm_mono (hf : 0 ‚â§ f) (hfg : f ‚â§ g) : ‚Äñf‚Äñ_[p] ‚â§ ‚Äñg‚Äñ_[p] :=
begin
  obtain rfl | hp := @eq_zero_or_pos _ _ p,
  { simp only [L0norm_eq_card, ennreal.some_eq_coe, ennreal.coe_zero, nat.cast_le],
    exact card_mono
      (set.finite.to_finset_mono $ Œª i, mt $ Œª hi, ((hfg i).trans_eq hi).antisymm $ hf i) },
  rw ‚Üênnreal.coe_pos at hp,
  simp_rw [‚Üêrpow_le_rpow_iff Lpnorm_nonneg Lpnorm_nonneg hp, Lpnorm_rpow_eq_sum hp,
    norm_of_nonneg (hf _), norm_of_nonneg (hf.trans hfg _)],
  exact sum_le_sum (Œª i _, rpow_le_rpow (hf _) (hfg _) hp.le),
end

end real

/-! #### Weighted Lp norm -/

section normed_add_comm_group
variables {Œ± : Œπ ‚Üí Type*} [Œ† i, normed_add_comm_group (Œ± i)] {p : ‚Ñù‚â•0} {w : Œπ ‚Üí ‚Ñù‚â•0}
  {f g h : Œ† i, Œ± i}

/-- The weighted Lp norm of a function. -/
noncomputable def wLpnorm (p : ‚Ñù‚â•0) (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œ† i, Œ± i) : ‚Ñù :=
‚Äñ(Œª i, w i ^ (p‚Åª¬π : ‚Ñù) ‚Ä¢ ‚Äñf i‚Äñ)‚Äñ_[p]

notation `‚Äñ` f `‚Äñ_[` p `, ` w `]` := wLpnorm p w f

@[simp] lemma wLpnorm_one_eq_Lpnorm (p : ‚Ñù‚â•0) (f : Œ† i, Œ± i) : ‚Äñf‚Äñ_[p, 1] = ‚Äñf‚Äñ_[p] :=
by obtain rfl | hp := @eq_zero_or_pos _ _ p; simp [wLpnorm, L0norm_eq_card, Lpnorm_eq_sum, *]

lemma wLpnorm_eq_sum (hp : 0 < p) (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p, w] = (‚àë i, w i ‚Ä¢ ‚Äñf i‚Äñ ^ (p : ‚Ñù)) ^ (p‚Åª¬π : ‚Ñù) :=
begin
  have : (p : ‚Ñù) ‚â† 0 := by positivity,
  simp_rw [wLpnorm, Lpnorm_eq_sum hp, nnreal.smul_def, norm_smul],
  simp only [nnreal.coe_rpow, norm_norm, algebra.id.smul_eq_mul, mul_rpow, norm_nonneg,
    rpow_nonneg_of_nonneg, hp.ne', nnreal.coe_nonneg, norm_of_nonneg, rpow_inv_rpow _ this],
end

lemma wLpnorm_eq_sum' {p : ‚Ñù} (hp : 0 < p) (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p.to_nnreal, w] = (‚àë i, w i ‚Ä¢ ‚Äñf i‚Äñ ^ p) ^ p‚Åª¬π :=
by rw wLpnorm_eq_sum; simp [hp, hp.le]

lemma wLpnorm_rpow_eq_sum {p : ‚Ñù‚â•0} (hp : 0 < p) (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p, w] ^ (p : ‚Ñù) = ‚àë i, w i ‚Ä¢ ‚Äñf i‚Äñ ^ (p : ‚Ñù) :=
begin
  rw [wLpnorm_eq_sum hp, rpow_inv_rpow],
  { exact sum_nonneg (Œª i _, by positivity) },
  { positivity }
end

lemma wLpnorm_pow_eq_sum {p : ‚Ñï} (hp : p ‚â† 0) (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p, w] ^ p = ‚àë i, w i ‚Ä¢ ‚Äñf i‚Äñ ^ p :=
by simpa using wLpnorm_rpow_eq_sum (nat.cast_pos.2 hp.bot_lt) w f

lemma wL1norm_eq_sum (w : Œπ ‚Üí ‚Ñù‚â•0) (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œ† i, Œ± i) : ‚Äñf‚Äñ_[1, w] = ‚àë i, w i ‚Ä¢ ‚Äñf i‚Äñ :=
by simp [wLpnorm_eq_sum]

lemma wL0norm_eq_card (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[0, w] = {i | f i ‚â† 0}.to_finite.to_finset.card :=
by simp [wLpnorm, L0norm_eq_card]

@[simp] lemma wLpnorm_zero (w : Œπ ‚Üí ‚Ñù‚â•0) : ‚Äñ(0 : Œ† i, Œ± i)‚Äñ_[p, w] = 0 :=
by simp [wLpnorm, ‚Üêpi.zero_def]

@[simp] lemma wLpnorm_norm (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œ† i, Œ± i) : ‚ÄñŒª i, ‚Äñf i‚Äñ‚Äñ_[p, w] = ‚Äñf‚Äñ_[p, w] :=
by obtain rfl | hp := @eq_zero_or_pos _ _ p; simp [wL0norm_eq_card, wLpnorm_eq_sum, *, ne_of_gt]

@[simp] lemma wLpnorm_neg (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œ† i, Œ± i) : ‚Äñ-f‚Äñ_[p, w] = ‚Äñf‚Äñ_[p, w] :=
by simp [‚ÜêwLpnorm_norm _ (-f)]

lemma wLpnorm_sub_comm (w : Œπ ‚Üí ‚Ñù‚â•0) (f g : Œ† i, Œ± i) : ‚Äñf - g‚Äñ_[p, w] = ‚Äñg - f‚Äñ_[p, w] :=
by simp [‚ÜêwLpnorm_neg _ (f - g)]

@[simp] lemma wLpnorm_nonneg : 0 ‚â§ ‚Äñf‚Äñ_[p, w] := Lpnorm_nonneg

section one_le

lemma wLpnorm_add_le (hp : 1 ‚â§ p) (w : Œπ ‚Üí ‚Ñù‚â•0) (f g : Œ† i, Œ± i) :
  ‚Äñf + g‚Äñ_[p, w] ‚â§ ‚Äñf‚Äñ_[p, w] + ‚Äñg‚Äñ_[p, w] :=
begin
  unfold wLpnorm,
  refine (Lpnorm_add_le (by exact_mod_cast hp ) _ _).trans'
    (Lpnorm_mono (Œª i, by dsimp; positivity) $ Œª i, _),
  dsimp,
  rw ‚Üêsmul_add,
  exact smul_le_smul_of_nonneg (norm_add_le _ _) (zero_le _),
end

lemma wLpnorm_sub_le (hp : 1 ‚â§ p) (w : Œπ ‚Üí ‚Ñù‚â•0) (f g : Œ† i, Œ± i) :
  ‚Äñf - g‚Äñ_[p, w] ‚â§ ‚Äñf‚Äñ_[p, w] + ‚Äñg‚Äñ_[p, w] :=
by simpa [sub_eq_add_neg] using wLpnorm_add_le hp w f (-g)

lemma wLpnorm_le_wLpnorm_add_wLpnorm_sub' (hp : 1 ‚â§ p) (w : Œπ ‚Üí ‚Ñù‚â•0) (f g  : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p, w] ‚â§ ‚Äñg‚Äñ_[p, w] + ‚Äñf - g‚Äñ_[p, w] :=
by simpa using wLpnorm_add_le hp w g (f - g)

lemma wLpnorm_le_wLpnorm_add_wLpnorm_sub (hp : 1 ‚â§ p) (w : Œπ ‚Üí ‚Ñù‚â•0) (f g  : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p, w] ‚â§ ‚Äñg‚Äñ_[p, w] + ‚Äñg - f‚Äñ_[p, w] :=
by rw [wLpnorm_sub_comm]; exact wLpnorm_le_wLpnorm_add_wLpnorm_sub' hp _ _ _

lemma wLpnorm_le_add_wLpnorm_add (hp : 1 ‚â§ p) (w : Œπ ‚Üí ‚Ñù‚â•0) (f g  : Œ† i, Œ± i) :
  ‚Äñf‚Äñ_[p, w] ‚â§ ‚Äñf + g‚Äñ_[p, w] + ‚Äñg‚Äñ_[p, w] :=
by simpa using wLpnorm_add_le hp w (f + g) (-g)

lemma wLpnorm_sub_le_Lpnorm_sub_add_Lpnorm_sub (hp : 1 ‚â§ p) :
  ‚Äñf - h‚Äñ_[p, w] ‚â§ ‚Äñf - g‚Äñ_[p, w] + ‚Äñg - h‚Äñ_[p, w] :=
by simpa using wLpnorm_add_le hp w (f - g) (g - h)

variables {ùïú : Type*} [normed_field ùïú] [Œ† i, normed_space ùïú (Œ± i)]

-- TODO: `p ‚â† 0` is enough
lemma wLpnorm_smul (hp : 1 ‚â§ p) (c : ùïú) (f : Œ† i, Œ± i) : ‚Äñc ‚Ä¢ f‚Äñ_[p, w] = ‚Äñc‚Äñ * ‚Äñf‚Äñ_[p, w] :=
begin
  rw [wLpnorm, wLpnorm],
  have : (1 : ‚Ñù‚â•0‚àû) ‚â§ p := by exact_mod_cast hp,
  have := Lpnorm_smul this (‚Äñc‚Äñ) (Œª i, w i ^ (p‚Åª¬π : ‚Ñù) ‚Ä¢ ‚Äñf i‚Äñ),
  rw norm_norm at this,
  rw ‚Üêthis,
  congr' with i : 1,
  simp only [pi.smul_apply, algebra.id.smul_eq_mul, algebra.mul_smul_comm, norm_smul],
end

-- TODO: Why is it so hard to use `wLpnorm_smul` directly? `function.has_smul` seems to have a hard
-- time unifying `pi.has_smul`
lemma wLpnorm_smul' {Œ± : Type*} [normed_add_comm_group Œ±] [normed_space ùïú Œ±] (hp : 1 ‚â§ p) (c : ùïú)
  (f : Œπ ‚Üí Œ±) : ‚Äñc ‚Ä¢ f‚Äñ_[p, w] = ‚Äñc‚Äñ * ‚Äñf‚Äñ_[p, w] :=
wLpnorm_smul hp _ _

variables [Œ† i, normed_space ‚Ñù (Œ± i)]

lemma wLpnorm_nsmul (hp : 1 ‚â§ p) (n : ‚Ñï) (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œ† i, Œ± i) :
  ‚Äñn ‚Ä¢ f‚Äñ_[p, w] = n ‚Ä¢ ‚Äñf‚Äñ_[p, w] :=
by rw [nsmul_eq_smul_cast ‚Ñù, wLpnorm_smul hp, is_R_or_C.norm_nat_cast, nsmul_eq_mul]

-- TODO: Why is it so hard to use `wLpnorm_nsmul` directly? `function.has_smul` seems to have a hard
-- time unifying `pi.has_smul`
lemma wLpnorm_nsmul' {Œ± : Type*} [normed_add_comm_group Œ±] [normed_space ‚Ñù Œ±] (hp : 1 ‚â§ p) (n : ‚Ñï)
  (w : Œπ ‚Üí ‚Ñù‚â•0) (f : Œπ ‚Üí Œ±) : ‚Äñn ‚Ä¢ f‚Äñ_[p, w] = n ‚Ä¢ ‚Äñf‚Äñ_[p, w] :=
wLpnorm_nsmul hp _ _ _

end one_le
end normed_add_comm_group

section real
variables {p : ‚Ñù‚â•0} {w : Œπ ‚Üí ‚Ñù‚â•0} {f g : Œπ ‚Üí ‚Ñù}

@[simp] lemma wLpnorm_one (hp : 0 < p) (w : Œπ ‚Üí ‚Ñù‚â•0) :
  ‚Äñ(1 : Œπ ‚Üí ‚Ñù)‚Äñ_[p, w] = (‚àë i, w i) ^ (p‚Åª¬π : ‚Ñù) :=
by simp [wLpnorm_eq_sum hp, nnreal.smul_def]

lemma wLpnorm_mono (hf : 0 ‚â§ f) (hfg : f ‚â§ g) : ‚Äñf‚Äñ_[p, w] ‚â§ ‚Äñg‚Äñ_[p, w] :=
Lpnorm_mono (Œª i, by dsimp; positivity) $ Œª i, smul_le_smul_of_nonneg
  (by rw [norm_of_nonneg (hf _), norm_of_nonneg (hf.trans hfg _)]; exact hfg _) $ by positivity

end real

/-! #### Inner product -/

section normed_add_comm_group
variables {Œ± : Œπ ‚Üí Type*} [Œ† i, normed_add_comm_group (Œ± i)] (ùïú : Type*) [add_comm_monoid ùïú]
  [Œ† i, has_inner ùïú (Œ± i)]

@[reducible] noncomputable def L2inner (f g : Œ† i, Œ± i) : ùïú :=
inner ((pi_Lp.equiv 2 _).symm f) ((pi_Lp.equiv 2 _).symm g)

notation `‚ü™`f`, `g`‚ü´_[`ùïú`]` := L2inner ùïú f g

lemma L2inner_eq_sum (f g : Œ† i, Œ± i) : ‚ü™f, g‚ü´_[ùïú] = ‚àë i, inner (f i) (g i) := rfl

end normed_add_comm_group

section Lpnorm
variables {Œ± Œ≤ : Type*} [add_comm_group Œ±] [fintype Œ±] {p : ‚Ñù‚â•0‚àû}

@[simp] lemma Lpnorm_translate [normed_add_comm_group Œ≤] (a : Œ±) (f : Œ± ‚Üí Œ≤) : ‚ÄñœÑ a f‚Äñ_[p] = ‚Äñf‚Äñ_[p] :=
begin
  cases p,
  { simp only [Linftynorm_eq_csupr, ennreal.none_eq_top, translate_apply],
    exact (equiv.sub_right _).supr_congr (Œª _, rfl) },
  obtain rfl | hp := @eq_zero_or_pos _ _ p,
  { simp only [L0norm_eq_card, translate_apply, ne.def, ennreal.some_eq_coe, ennreal.coe_zero,
      nat.cast_inj],
    exact card_congr (Œª x _, x - a) (Œª x hx, by simpa using hx)
      (Œª x y _ _ h, by simpa using h) (Œª x hx, ‚ü®x + a, by simpa using hx‚ü©) },
  { simp only [Lpnorm_eq_sum hp, ennreal.some_eq_coe, translate_apply],
    congr' 1,
    exact fintype.sum_equiv (equiv.sub_right _) _ _ (Œª _, rfl) }
end

@[simp] lemma Lpnorm_conj [is_R_or_C Œ≤] (f : Œ± ‚Üí Œ≤) : ‚Äñconj f‚Äñ_[p] = ‚Äñf‚Äñ_[p] :=
begin
  cases p, swap, obtain rfl | hp := @eq_zero_or_pos _ _ p,
  all_goals { simp only [Linftynorm_eq_csupr, Lpnorm_eq_sum, L0norm_eq_card, ennreal.some_eq_coe,
    ennreal.none_eq_top, ennreal.coe_zero, pi.conj_apply, is_R_or_C.norm_conj, map_ne_zero, *] },
end

@[simp] lemma Lpnorm_conjneg [is_R_or_C Œ≤] (f : Œ± ‚Üí Œ≤) : ‚Äñconjneg f‚Äñ_[p] = ‚Äñf‚Äñ_[p] :=
begin
  simp only [conjneg, Lpnorm_conj],
  cases p,
  { simp only [Linftynorm_eq_csupr, ennreal.none_eq_top, conjneg, is_R_or_C.norm_conj],
    exact (equiv.neg _).supr_congr (Œª _, rfl) },
  obtain rfl | hp := @eq_zero_or_pos _ _ p,
  { simp only [L0norm_eq_card, ne.def, ennreal.some_eq_coe, ennreal.coe_zero, nat.cast_inj],
    exact card_congr (Œª x _, -x) (Œª x hx, by simpa using hx) (Œª x y _ _, neg_inj.1)
      (Œª x hx, ‚ü®-x, by simpa using hx‚ü©) },
  { simp only [Lpnorm_eq_sum hp, ennreal.some_eq_coe],
    congr' 1,
    exact fintype.sum_equiv (equiv.neg _) _ _ (Œª _, rfl) }
end

end Lpnorm

section wLpnorm
variables {Œ± Œ≤ : Type*} [add_comm_group Œ±] [fintype Œ±] {p : ‚Ñù‚â•0} {w : Œ± ‚Üí ‚Ñù‚â•0}

@[simp] lemma wLpnorm_translate [normed_add_comm_group Œ≤] (a : Œ±) (f : Œ± ‚Üí Œ≤) :
  ‚ÄñœÑ a f‚Äñ_[p, œÑ a w] = ‚Äñf‚Äñ_[p, w] :=
(Lpnorm_translate a (Œª i, w i ^ (p‚Åª¬π : ‚Ñù) ‚Ä¢ ‚Äñf i‚Äñ) : _)

@[simp] lemma wLpnorm_conj [is_R_or_C Œ≤] (f : Œ± ‚Üí Œ≤) : ‚Äñconj f‚Äñ_[p, w] = ‚Äñf‚Äñ_[p, w] :=
by simp [wLpnorm]

@[simp] lemma wLpnorm_conjneg [is_R_or_C Œ≤] (f : Œ± ‚Üí Œ≤) : ‚Äñconjneg f‚Äñ_[p] = ‚Äñf‚Äñ_[p] :=
by simp [wLpnorm]

end wLpnorm

namespace tactic
open positivity

private alias Lpnorm_pos ‚Üî _ Lpnorm_pos_of_ne_zero

private lemma Lpnorm_pos_of_pos {p : ‚Ñù‚â•0‚àû} {f : Œπ ‚Üí ‚Ñù} (hf : 0 < f) : 0 < ‚Äñf‚Äñ_[p] :=
Lpnorm_pos_of_ne_zero hf.ne'

/-- Extension for the `positivity` tactic: Lp norms are nonnegative, and is strictly positive if its
input is nonzero. -/
@[positivity]
meta def positivity_Lpnorm : expr ‚Üí tactic strictness
| `(‚Äñ%%f‚Äñ_[%%p]) := do
  (do -- if can prove `0 < a` or `a ‚â† 0`, report positivity
    strict_a ‚Üê core f,
    match strict_a with
    | positive hp := positive <$> mk_mapp ``Lpnorm_pos_of_pos [none, none, p, f, hp]
    | nonzero hp := positive <$> mk_mapp ``Lpnorm_pos_of_ne_zero [none, none, none, none, p, f, hp]
    | _ := failed
    end) <|>
  -- else report nonnegativity
  (nonnegative <$> mk_mapp ``Lpnorm_nonneg [none, none, none, none, p, f])
| e := pp e >>= fail ‚àò format.bracket "The expression `" "` isn't of the form `‚Äñf‚Äñ_[p]`"

/-- Extension for the `positivity` tactic: Lp norms are nonnegative, and is strictly positive if its
input is nonzero. -/
@[positivity]
meta def positivity_wLpnorm : expr ‚Üí tactic strictness
| `(‚Äñ%%f‚Äñ_[%%p, %%w]) := nonnegative <$> mk_mapp ``wLpnorm_nonneg [none, none, none, none, p, w, f]
| e := pp e >>= fail ‚àò format.bracket "The expression `" "` isn't of the form `‚Äñf‚Äñ_[p, w]`"

end tactic

section examples
variables {Œ± : Œπ ‚Üí Type*} [Œ† i, normed_add_comm_group (Œ± i)] {w : Œπ ‚Üí ‚Ñù‚â•0} {f : Œ† i, Œ± i}

example {p : ‚Ñù‚â•0‚àû} : 0 ‚â§ ‚Äñf‚Äñ_[p] := by positivity
example {p : ‚Ñù‚â•0‚àû} (hf : f ‚â† 0) : 0 < ‚Äñf‚Äñ_[p] := by positivity
example {p : ‚Ñù‚â•0‚àû} {f : Œπ ‚Üí ‚Ñù} (hf : 0 < f) : 0 < ‚Äñf‚Äñ_[p] := by positivity
example {p : ‚Ñù‚â•0} : 0 ‚â§ ‚Äñf‚Äñ_[p, w] := by positivity

end examples

/-! ### H√∂lder inequality -/

section Lpnorm
variables {Œ± : Type*} [fintype Œ±]

/-- H√∂lder's inequality, binary case. -/
lemma Lpnorm_mul_le (p q r : ‚Ñù‚â•0‚àû) (hpqr : p‚Åª¬π + q‚Åª¬π = r‚Åª¬π) (f g : Œ± ‚Üí ‚ÑÇ) :
  ‚Äñf * g‚Äñ_[r] ‚â§ ‚Äñf‚Äñ_[p] * ‚Äñg‚Äñ_[q] :=
begin
  sorry, --TODO: Bhavik
end

/-- H√∂lder's inequality, finitary case. -/
lemma Lpnorm_prod_le {s : finset Œπ} (p : Œπ ‚Üí ‚Ñù‚â•0‚àû) (q : ‚Ñù‚â•0‚àû) (hpq : ‚àë i in s, (p i)‚Åª¬π = q‚Åª¬π)
  (f : Œπ ‚Üí Œ± ‚Üí ‚ÑÇ) : ‚Äñ‚àè i in s, f i‚Äñ_[q] ‚â§ ‚àè i in s, ‚Äñf i‚Äñ_[p i] :=
begin
  classical,
  induction s using finset.induction with i s hi ih,
  sorry { simp },
  sorry --TODO: Bhavik
end

end Lpnorm

/-! ### Indicator -/

section mu
variables {Œ± Œ≤ : Type*} [is_R_or_C Œ≤] [fintype Œ±] [decidable_eq Œ±] {s : finset Œ±} {p : ‚Ñù‚â•0}

lemma Lpnorm_mu (hp : 1 ‚â§ p) (hs : s.nonempty) : ‚ÄñŒº_[Œ≤] s‚Äñ_[p] = s.card ^ (p‚Åª¬π - 1 : ‚Ñù) :=
begin
  have : (s.card : ‚Ñù) ‚â† 0 := nat.cast_ne_zero.2 hs.card_pos.ne',
  rw [mu, Lpnorm_smul'], swap,
  { exact_mod_cast hp },
  replace hp := zero_lt_one.trans_le hp,
  simp only [map_inv‚ÇÄ, complex.abs_cast_nat, smul_eq_mul, Lpnorm_eq_sum hp, complex.norm_eq_abs],
  have : ‚àÄ x, (ite (x ‚àà s) 1 0 : ‚Ñù) ^ (p : ‚Ñù) = ite (x ‚àà s) (1 ^ (p : ‚Ñù)) (0 ^ (p : ‚Ñù)) :=
    Œª x, by split_ifs; simp,
  simp_rw [indicator_apply, apply_ite has_norm.norm, norm_one, norm_zero, norm_inv,
    is_R_or_C.norm_nat_cast, this, zero_rpow (nnreal.coe_ne_zero.2 hp.ne'), one_rpow, sum_boole,
    filter_mem_eq_inter, univ_inter, rpow_sub_one ‚Äπ_‚Ä∫, inv_mul_eq_div],
end

lemma Lpnorm_mu_le (hp : 1 ‚â§ p) : ‚ÄñŒº_[Œ≤] s‚Äñ_[p] ‚â§ s.card ^ (p‚Åª¬π - 1 : ‚Ñù) :=
begin
  obtain rfl | hs := s.eq_empty_or_nonempty,
  { simp,
    positivity },
  { exact (Lpnorm_mu hp hs).le }
end

lemma L1norm_mu (hs : s.nonempty) : ‚ÄñŒº_[Œ≤] s‚Äñ_[1] = 1 := by simpa using Lpnorm_mu le_rfl hs

lemma L1norm_mu_le_one : ‚ÄñŒº_[Œ≤] s‚Äñ_[1] ‚â§ 1 := by simpa using Lpnorm_mu_le le_rfl

end mu
